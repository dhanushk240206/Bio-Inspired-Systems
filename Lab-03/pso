import random
import math

# --------------------------
# Environment Setup
# --------------------------
start = (0, 0)
goal = (10, 10)
# obstacles are rectangles defined by bottom-left and top-right corners
obstacles = [((3, 3), (5, 5)), ((6, 7), (8, 9))]

def is_collision(p1, p2):
    """Check if the line between p1 and p2 intersects any rectangular obstacle."""
    for (bl, tr) in obstacles:
        x1, y1 = bl
        x2, y2 = tr
        if (min(p1[0], p2[0]) < x2 and max(p1[0], p2[0]) > x1 and
            min(p1[1], p2[1]) < y2 and max(p1[1], p2[1]) > y1):
            return True
    return False

def path_length(path):
    """Fitness function = total path length + penalty for collisions."""
    length = 0
    for i in range(len(path)-1):
        p1, p2 = path[i], path[i+1]
        if is_collision(p1, p2):
            return 10**6  # big penalty
        length += math.dist(p1, p2)
    return length

# --------------------------
# Particle Class
# --------------------------
class Particle:
    def __init__(self, num_waypoints, bounds):
        self.position = [(random.uniform(bounds[0][0], bounds[0][1]),
                          random.uniform(bounds[1][0], bounds[1][1]))
                         for _ in range(num_waypoints)]
        self.velocity = [(0, 0) for _ in range(num_waypoints)]
        self.best_position = list(self.position)
        self.best_value = float("inf")

    def evaluate(self, func):
        path = [start] + self.position + [goal]
        value = func(path)
        if value < self.best_value:
            self.best_value = value
            self.best_position = list(self.position)
        return value

    def update_velocity(self, global_best, w, c1, c2):
        new_velocity = []
        for i in range(len(self.position)):
            r1, r2 = random.random(), random.random()
            vx = (w * self.velocity[i][0] +
                  c1 * r1 * (self.best_position[i][0] - self.position[i][0]) +
                  c2 * r2 * (global_best[i][0] - self.position[i][0]))
            vy = (w * self.velocity[i][1] +
                  c1 * r1 * (self.best_position[i][1] - self.position[i][1]) +
                  c2 * r2 * (global_best[i][1] - self.position[i][1]))
            new_velocity.append((vx, vy))
        self.velocity = new_velocity

    def update_position(self, bounds):
        new_position = []
        for i in range(len(self.position)):
            x = self.position[i][0] + self.velocity[i][0]
            y = self.position[i][1] + self.velocity[i][1]
            # clamp inside environment
            x = max(bounds[0][0], min(x, bounds[0][1]))
            y = max(bounds[1][0], min(y, bounds[1][1]))
            new_position.append((x, y))
        self.position = new_position

# --------------------------
# PSO Class
# --------------------------
class PSO:
    def __init__(self, func, num_waypoints=3, bounds=[(0, 10), (0, 10)],
                 num_particles=20, max_iter=100, w=0.5, c1=1.5, c2=1.5):
        self.func = func
        self.num_waypoints = num_waypoints
        self.bounds = bounds
        self.swarm = [Particle(num_waypoints, bounds) for _ in range(num_particles)]
        self.global_best_position = list(self.swarm[0].position)
        self.global_best_value = float("inf")
        self.max_iter = max_iter
        self.w, self.c1, self.c2 = w, c1, c2

    def run(self):
        for _ in range(self.max_iter):
            for particle in self.swarm:
                value = particle.evaluate(self.func)
                if value < self.global_best_value:
                    self.global_best_value = value
                    self.global_best_position = list(particle.best_position)

            for particle in self.swarm:
                particle.update_velocity(self.global_best_position, self.w, self.c1, self.c2)
                particle.update_position(self.bounds)

        return self.global_best_position, self.global_best_value

# --------------------------
# Run PSO for Path Planning
# --------------------------
if __name__ == "__main__":
    pso = PSO(func=path_length, num_waypoints=3, max_iter=100)
    best_path, best_value = pso.run()

    full_path = [start] + best_path + [goal]
    print("Best Path Found:")
    for p in full_path:
        print(p)
    print("Total Path Length:", best_value)
